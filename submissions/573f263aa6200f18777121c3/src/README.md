# [Hola JS Challenge Spring 2016: Word Classifier](https://github.com/hola/challenge_word_classifier)

## Введение

Для решения задачи классификации был выбран метод статистического анализа исходного текста.

## Немного теории

Пусть ```A``` - исходный алфавит - упорядоченное множество (```[a-z\'], a < b < c < ... < z < \'```).
Мощность ```|A|=27``` (количество элементов множества). 

Пронумеруем последовательно все элементы множества:
```
idx(a) = 0
idx(b) = 1
...
idx(z) = 25
idx(\') = 27
```
Любое множество ```F```<sub>n</sub>, состоящее из последовательностей  длиной 
```n``` элементов из ```A``` можно задать с помощью ```n``` <sup>27</sup> бит. 

Например, последовательность биграмм определяется следующим образом:
```
aa => 0
ab => 1
...
a\' => 26
ba => 27
...
\'\' => 728 = 27^27 - 1
```

Наличие, либо отсутсвие элемента в множестве будем представлять ```1``` или ```0``` в соответствующем месте последовательности.

Например, множество ```{ac, ae}``` задается последовательностью ```001010...0``` длиной 729 бит (92 байта).

| Длина элементов | Мощность множества | Размер в байтах |
| :--- | :--- | :--- |
| 1 | 27     | 4    |
| 2 | 729    | 92   |
| 3 | 19683  | 2461 |
| 4 | 531441 | 66431|

*Таблица 1*


## Практика

Как видно из *Таблицы 1*, использование множеств, состоящих 
из последовательностей более трех символов длиной невозможно без дополнительного сжатия.
К счастью, ```gzip``` частично справляется с этой задачей.

По реузльтатам исследования выбрано несколько статистических метрик для фильтрации слов:
* Анализ статистики последовательно встречающихся символов длиной 1-4
* Анализ статистики "разреженных" данных. В этои случае также учитывается 
позиция первого символа последовательности. Например в последовательности ```abcdefgh``` 
учитывается взаимное сочетание символов, размещенных в позициях:
 * 1,3,5 (```ace```)
 * 2,4,6 (```bdf```)
 * и т.д.

Кроме того, если искомая последовательность встречается менее определенного количества раз,
будем считать это "шумом" и не будем учитывать в финальной статике. Коэффициенты для 
каждого вида последовательности были выведены эмпирическим путем.

Получив статистику по словарю, упаковываем ее в однин файл и сжимаем с помощью библиотеки ```zlib```.

Перед началом тестирования данные статистики преобразовываются в соответствующие словари.
При анализе происходит поиск вхождений сиволов слова в словарях. 
Если найдена хотя бы одна последовательность, не входящая в словарь, проверка прекращается и слово считается недействительным. 

## Сборка проекта

Для автоматического анализа файла ```words.txt``` и формирования статистики запустите скрипт ```npm run make```.
В директории ```./data``` будут созданы файлы ```data.bin``` и ```data.gz```. Для дальнейшей работы используйте второй файл.

Результат фильтрации слов можно увидеть, запустив скрипт ```npm start [filename]```

## Автор

Русскин Николай <nrusskin@gmail.com>
