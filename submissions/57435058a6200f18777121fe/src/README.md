# The ElStr Solution### Solution ApproachThe initial approach to solve the challenge was to use the [bloom filter](https://en.wikipedia.org/wiki/Bloom_filter) data structure. This structure has the con of *False Positive* matches, but the greater pro is that *False Negatives* are not possible for a **full** set, or in another terminology query returns either "possibly in set" or "definitely not in set".### Solution buildupFor generating the filter, Python 2.7 was the easy answer for me, since it has excellent data manipulation capability.The following workflow was used:1. Filter size evaluation as a result of the 64K bytes limitation. Initial array state is all *zero*.2. Scanning the *"words.txt"* supplied by the Challenge team revealed multiple repetition and subtle manipulation of the same word. First, all words read as *lower case* only. Then, a *basic* dictionary was processed:  * Building statistics of suffix and prefix letters in the Dictionary.  * Iterating out **popular** suffixes from dictionary: *'s*, *es*, *er*, *ed*, *ly* & *ing*.  * Then, iterating out the prefixes: *un*, *co*, *re*, *in*, *pre* & *pro*.  * Each iteration repeated itself until all possible combinations of the basic word were removed. itertation always terminated before *zero-length* word remained:     - 'abcedinged' and 'incoreabd' were iterated to 'abc' and 'abd'.     - 'esinged' iterated to 'es' and 'uncore' iterated to 're'.3. Every word in the *processed* dictionary hashed with Python built-in **CRC32** function. For compatibility with *JavaScript* unsigned number type, all hashes were bitwise *and* (*&*) with 0x0FFFFFFFF. Then the hash was *folded* into the ***filter array pointer*** using **Modulus** of the filter size.4. The resulted pointer manipulated the relevant cell in the array to '1'.This gives a ***bloom filter*** with no *False Negative* but with a high *False Positive* rate.The results were tested against the public test case generator and binominal distribution was asserted, so validity of the approach was confirmed.### Statistical infrastructureUsing the link provided by the challenge team: [public test case generator](https://hola.org/challenges/word_classifier/testcase) and going over quiet a large sum of test files, it was possible to create a statistical basis of hash codes repetition for *True* test words and for *False* test case words. The *difference* per hash code was recorded. Using a *threshold* named **CFNR** (Common False Negative Ratio), it was possible to zero down the relevant bits in our filter array.Length of each word was also recorded. That gave the possibility of graphing the length distribution for *True* and *False* test case words. Assessing the result revealed that *False* test case words tend to be longer then *True* test case words. A *threshold* named **CLEN** prevented from *too-long* words to enter both the dictionary and the CFNR array.All this adds ***False Negative*** to the resulted filter, but the overall performance improves.### Generating the *data* fileAfter evaluation, CFNR of 1 and CLEN of 15 were established for best results. By subtracting the API Code length (now finished in parallel to the generator), we could decide on the best filter size and saving the compressed data file:  * Using simple bit manipulation, the filter array was folded to a buffer the size of *floor(array/8)*.  * Each '1' element in the filter array was saved as a 'on' bit in the buffer.  * The resulting **Binary Array** was saved as ***data*** file.  * Further gzip compression was evaluated to be unsuccessful.### API CodeThe *JavaScript* code handles both needed functions (*init* and *test*) for the Challenge.***init***  gets the *address* of the File filter created by the Python generator from the supporting mechanism (Node.js) and assign it to the appropriate Unsigned 8bit array. For an unsuccessful assignment, 'Undefined' is returned. The successful assigned array will serve the *test* function.***test*** gets a *string*. The same workflow as in the Python Generator of processing the word is done. This allows greater compatibility and fewer *False Positive* errors:1. Returning ***false*** for words longer than the CLEN parameter.1. Removing *Suffixes* and *Prefixes* in the same order as the generator process.1. Calculating the folded hash code (with the help of a utilized CRC32 function).1. Calculating the Byte using *hashcode / 8* and Bit using *hashcode % 8*.1. Extracting the relevant bit from the data file array, and returning ***true*** for 1 and ***false*** for 0.### ConclusionThis project was *great fun*, using brain storming and studying new material. Discovering different aspects of word structure recognition techniques, probabilistic data structures and statistical analysis help getting to a successful admission to the challenge.