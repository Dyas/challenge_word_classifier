Автор:	XorNur@gmail.com

Решение задачи https://habrahabr.ru/company/hola/blog/282624/

Идея заключается в том, чтоб не забраковать ни одного верного слова. Ложные слова определяются по нахождению в них запрещённых (для данной длины слова и положения) комбинаций символов

Описание алгоритма
1. Считаем верным
* однобуквенные слова,
* двухбуквенные слова, оканчивающиеся на “s”,
* трёхбуквенные слова, оканчивающиеся на “’s”,
* слова из списка исключений (z) из файла данных
2. Считаем ложными
* слова длиннее 24-х символов,
* слова с тильдой в местах отличных от предпоследней позиции слова с последующим символом “s”
3. Определяем тип слова
* оканчивающиеся на “’s”,
* прочие, оканчивающиеся на “s”,
* прочие (без “s” на конце)
4. Берём массив правил (can), соответствующий типу слова и убираем из слова окончание (“’s” или “s” или ничего)
5. Каждую пару букв слова (cc) проверяем по массиву правил на возможность нахождения этой пары в слове длинны l в соответствующей позиции t. Если пара букв не может встречаться в слове длинны l в позиции t, считаем слово ложным
6. Считаем слово верным

Файл данных
Файл данных состоит из двух частей
1. Слова исключения из правил
Это список верных слов, но не удовлетворяющих накладываемым правилам (например, верные слова длиннее 24-х символов)
Для экономии размера слова хранятся в файле по алфавиту с сокращением текущего слова на общий с предыдущим словом префикс, длинна общего префикса используется в качестве разделителя слов
2. Допустимые позиции для комбинаций символов
Здесь последовательно идёт три блока бит, по одному блоку на каждый тип слов. В каждом блоке последовательно идут участки соответствующие разным парам букв (aa, ab, ..., zz). Первые 24 бита (биты длинны) хранят информацию о возможности нахождения пары букв в словах длинной равной номеру бита. Потом для каждой возможной комбинации идут биты позиций (от 2 до 23 бит, в зависимости от длины), показывающие в каких позициях слова пара букв может встречаться. Биты позиций не нужны если бит длины равен 0 и если длинна равна 2 (так как позиция может быть толь одна)

Ошибки
В импортируемой функции test неверно определяется тип тестируемого слова. Из-за чего тип слова всегда равен 2
Должно быть
	var q=2
	if(/.s$/.test(w))
		q=1
	if(/.'s$/.test(w))
		q=0
вместо
	var q=2
	if(/^.s$/.test(w))
		q=1
	if(/^.'s$/.test(w))
		q=0
Мне не хватило свободного времени
