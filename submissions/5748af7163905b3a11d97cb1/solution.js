// Generated by CoffeeScript 1.10.0
var CCIP, maxCharsInWord, maxCountChars, maxDistance3Chars, minCountChars;

maxCharsInWord = 19;

maxDistance3Chars = 6;

minCountChars = 2;

maxCountChars = 3;

CCIP = (function() {
  function CCIP() {}

  CCIP.prototype.init = function(data) {
    var alphabet, char, code, codeAlphabet, countChars, endChar, gComb, getGeneratorComb, i, iChar, j, obj, pit, position, positionInBuff, prefix, prefixTree, ref, ref1, ref2, setRgForTest;
    getGeneratorComb = function*(countChars, comb) {
      var char, i, len, oldComb;
      if (comb == null) {
        comb = '';
      }
      oldComb = comb;
      countChars -= 1;
      for (i = 0, len = alphabet.length; i < len; i++) {
        char = alphabet[i];
        comb = oldComb + char;
        if (countChars === 0) {
          (yield comb);
        }
        if (countChars !== 0) {
          (yield* getGeneratorComb(countChars, comb));
        }
      }
    };
    setRgForTest = (function(_this) {
      return function() {
        var chars, decodePosition, distance, endChar, i, j, k, len, position, prefix, ref, ref1, secondDistance;
        _this.rgForTest = '';
        decodePosition = [];
        for (distance = i = 0, ref = maxDistance3Chars; 0 <= ref ? i <= ref : i >= ref; distance = 0 <= ref ? ++i : --i) {
          for (secondDistance = j = 0, ref1 = maxDistance3Chars - distance; 0 <= ref1 ? j <= ref1 : j >= ref1; secondDistance = 0 <= ref1 ? ++j : --j) {
            decodePosition.push([distance, secondDistance]);
          }
        }
        for (prefix in prefixTree) {
          endChar = prefixTree[prefix];
          for (position = k = 0, len = endChar.length; k < len; position = ++k) {
            chars = endChar[position];
            if (chars) {
              if (prefix.length === 1) {
                _this.rgForTest += "|" + prefix + (position ? '.{' + position + '}' : '') + "[" + (chars.join('')) + "]";
              } else {
                distance = decodePosition[position];
                _this.rgForTest += "|" + prefix[0] + (distance[0] ? '.{' + distance[0] + '}' : '') + prefix[1] + (distance[1] ? '.{' + distance[1] + '}' : '') + "[" + (chars.join('')) + "]";
              }
            }
          }
        }
        _this.rgForTest = new RegExp(_this.rgForTest.slice(1));
      };
    })(this);
    alphabet = (function() {
      var i, results;
      results = [];
      for (char = i = 97; i <= 122; char = ++i) {
        results.push(String.fromCharCode(char));
      }
      return results;
    })();
    alphabet.push('\'');
    pit = 0xFF;
    prefixTree = {};
    positionInBuff = 0;
    for (countChars = i = ref = minCountChars, ref1 = maxCountChars; ref <= ref1 ? i <= ref1 : i >= ref1; countChars = ref <= ref1 ? ++i : --i) {
      gComb = getGeneratorComb(countChars - 1);
      while (!(obj = gComb.next()).done) {
        endChar = [];
        while (true) {
          code = data.slice(positionInBuff, positionInBuff + 4);
          if (code[0] === pit) {
            positionInBuff++;
            break;
          }
          positionInBuff += 4;
          position = code[0] >>> 3;
          codeAlphabet = code.readInt32BE();
          for (iChar = j = 0, ref2 = alphabet.length; 0 <= ref2 ? j < ref2 : j > ref2; iChar = 0 <= ref2 ? ++j : --j) {
            if (codeAlphabet >>> iChar & 0x00000001) {
              (endChar[position] || (endChar[position] = [])).push(alphabet[iChar]);
            }
          }
        }
        if (endChar.length) {
          prefix = obj.value;
          prefixTree[prefix] = endChar;
        }
      }
    }
    setRgForTest();
  };

  CCIP.prototype.test = function(word) {
    return !this.rgForTest.test(word);
    return true;
  };

  return CCIP;

})();

module.exports = new CCIP();
